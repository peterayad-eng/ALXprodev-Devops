#!/bin/bash

# Configuration
POKEMON_LIST=("bulbasaur" "ivysaur" "venusaur" "charmander" "charmeleon")
API_BASE="https://pokeapi.co/api/v2/pokemon"
OUTPUT_DIR="pokemon_data"
MAX_CONCURRENT=3
ERROR_LOG="parallel_errors.log"
TIMEOUT_SECONDS=15

# Initialize
mkdir -p "$OUTPUT_DIR"
rm -f "$ERROR_LOG"
declare -A pids
trap 'kill_all_processes' EXIT TERM INT

# Function to clean up processes
kill_all_processes() {
    echo -e "\nTerminating all background processes..."
    for pid in "${!pids[@]}"; do
        kill "$pid" 2>/dev/null && echo "Killed PID $pid (${pids[$pid]})"
    done
    exit 1
}

# Function to fetch single PokÃ©mon
fetch_pokemon() {
    local pokemon=$1
    local temp_file=$(mktemp)
    local status=1

    if curl -s -X GET "$API_BASE/$pokemon" \
        -H "Accept: application/json" \
        --max-time "$TIMEOUT_SECONDS" \
        --output "$temp_file" \
        --fail >/dev/null 2>&1 && \
        jq -e . "$temp_file" >/dev/null 2>&1; then
        mv "$temp_file" "$OUTPUT_DIR/$pokemon.json"
        echo "$pokemon"
        status=0
    else
        echo "$pokemon" >> "$ERROR_LOG"
        rm -f "$temp_file"
    fi

    return $status
}

# Main execution
echo "Starting parallel fetch (max $MAX_CONCURRENT concurrent requests)..."
for pokemon in "${POKEMON_LIST[@]}"; do
    # Check and limit concurrent processes
    while [ $(jobs -rp | wc -l) -ge $MAX_CONCURRENT ]; do
        sleep 0.5
    done

    fetch_pokemon "$pokemon" &
    pids[$!]=$pokemon
    echo "Started PID $! for $pokemon"
done

# Wait for completion and track results
completed=0
failed=0
for pid in "${!pids[@]}"; do
    if wait "$pid"; then
        completed=$((completed + 1))
    else
        failed=$((failed + 1))
        # Ensure process is terminated
        kill "$pid" 2>/dev/null
    fi
    unset "pids[$pid]"
done

echo -e "\nResults:"
echo "Successfully fetched: $completed"
echo "Failed: $failed"
[ -s "$ERROR_LOG" ] && echo "Check $ERROR_LOG for details"

exit 0
